package basic.step01;

// 블록과 변수의 범위
public class Variable07 {

	int a = 10;	// 멤버 변수

	public void 메소드1(int b) {
		/* 테스트 1 : 멤버 변수와 같은 이름의 지역 변수 선언 가능 */
		int a = 20;	// 지역 변수
		int c = 30;	// 지역변수

		/* 테스트 2 : 같은 블럭 내에서 같은 이름의 지역변수를 선언할 수 없다. */
		//int b = 20;	// 오류 : 이미 이 블럭 내에 b라는 지역 변수가 있다.
		// '메소드1'의 인자변수로 이미 선언되어 있지 않은가?
		//int c = 30;	// 오류 : 이미 이 블럭 내에 c라는 지역 변수가 있다.

		System.out.println("a = " + a + ", b = " + b + ", c = " + c);

		/* 테스트 3 : 메소드 안에 중첩 코드 블럭을 둘 수 있다. */
		{
			int t = 100;	// 지역 변수 선언 가능
			// 단, 이 블럭을 벗어나면 t 변수는 소멸된다.

			/* 테스트 4 :  메소드 안에서의 중첩 블럭내에서는 메소드의 지역변수와 
			 * 같은 이름의 변수를 선언할 수 없다. */
			//int c = 100; // 오류 : 이미 상위 블럭에 지역변수 c가 선언되어 있다.

			a = 200;	// 블럭 밖의 변수를 사용할 수 있다.
			b = 300;
			c = 400;

			/* 테스트 5 : 코드블럭 내에 또 다른 블럭을 중첩하여 만들 수 있다. 
			 *			 물론 변수 선언 법칙은 "테스트 3"와 같다. */
			{
				int p = 1000;
				t = 20; //ok
			}
			//p = 100; // 물론 사용이 불가능하다. 블럭이 끝나면서 p변수는 소멸이
			// 되었기 때문이다.
		}

		System.out.println("a = " + a + ", b = " + b + ", c = " + c);

		/* 테스트 6 : 블럭내의 변수는 블럭을 벗어나서 사용할 수 없다. */
		// t = 1000;

		/* 테스트 7 : 메소드명이나 클래스 명과 같은 이름을 가진 변수를 선언할 수 있다. */
		int VariableTest07 = 10000;
		int 메소드1 = 10000;
		/* 그러나, 위와 같이 클래스명이나 메소드명과 같은 이름을 가진 변수를
		 * 되도록 아니... 제발(please~~) 선언하지 말기를 바란다. 의미도 없을 뿐더러, 
		 * 오히려 소스코드의 혼동만 가중된다. */
		System.out.println("VariableTest_6 = " + VariableTest07 +
				", 메소드1 = " + 메소드1);
	}

	public static void main(String[] args) 
	{
		// 클래스와 객체에 대해 당장은 몰라도 상관없다... 어차피 앞으로 배울테니까..
		Variable07 객체 = new Variable07();
		객체.메소드1(1000);

		// 객체 멤버 변수 a 값을 출력
		System.out.println("객체.a = " + 객체.a);
	}

}
